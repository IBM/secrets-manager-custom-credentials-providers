package job

// Auto-generated by secrets-manager-job-generator

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"reflect"
	"strconv"
	"strings"

	"github.com/IBM/go-sdk-core/v5/core"
	sm "github.com/IBM/secrets-manager-go-sdk/v2/secretsmanagerv2"
	"github.com/go-playground/validator"
)

// Config holds all configuration settings
type Config struct {
	// Common fields
	SM_ACCESS_APIKEY     string
	SM_INSTANCE_URL      string
	SM_SECRET_GROUP_ID   string
	SM_SECRET_NAME       string
	SM_SECRET_TASK_ID    string
	SM_CREDENTIALS_ID    string
	SM_SECRET_VERSION_ID string
	SM_SECRET_ID         string
	SM_ACTION            string
	SM_TRIGGER           string

	// User fields
	SM_COMMON_NAME     string // From env: SMIN_COMMON_NAME
	SM_ORG             string // From env: SMIN_ORG
	SM_COUNTRY         string // From env: SMIN_COUNTRY
	SM_SAN             string // From env: SMIN_SAN
	SM_EXPIRATION_DAYS int    // From env: SMIN_EXPIRATION_DAYS
	SM_KEY_ALGO        string // From env: SMIN_KEY_ALGO
	SM_SIGN_ALGO       string // From env: SMIN_SIGN_ALGO
}

// CredentialsPayload contains fields for SMOUT_ environment variables
type CredentialsPayload struct {
	PRIVATE_KEY_BASE64 string `json:"private_key_base64" validate:"required,max=100000"`
	CERTIFICATE_BASE64 string `json:"certificate_base64" validate:"required,max=100000"`
}

// ConfigFromEnv creates a Config from environment variables and validates it
func ConfigFromEnv() (Config, error) {
	var config Config
	var errs []string

	// Declare common variables
	var value string
	var processedValue interface{}
	var err error
	// Process common variables
	value, err = MustGetEnvVar("SM_ACCESS_APIKEY")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_ACCESS_APIKEY = value
	}

	value, err = MustGetEnvVar("SM_INSTANCE_URL")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_INSTANCE_URL = value
	}

	value, err = MustGetEnvVar("SM_SECRET_GROUP_ID")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_SECRET_GROUP_ID = value
	}

	value, err = MustGetEnvVar("SM_SECRET_NAME")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_SECRET_NAME = value
	}

	value, err = MustGetEnvVar("SM_SECRET_TASK_ID")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_SECRET_TASK_ID = value
	}

	value = GetEnvVar("SM_CREDENTIALS_ID")
	config.SM_CREDENTIALS_ID = value

	value = GetEnvVar("SM_SECRET_VERSION_ID")
	config.SM_SECRET_VERSION_ID = value

	value, err = MustGetEnvVar("SM_SECRET_ID")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_SECRET_ID = value
	}

	value, err = MustGetEnvVar("SM_ACTION")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_ACTION = value
	}

	value, err = MustGetEnvVar("SM_TRIGGER")
	if err != nil {
		errs = append(errs, err.Error())
	} else {
		config.SM_TRIGGER = value
	}

	// Process user variables
	// Process SM_COMMON_NAME as string
	value = GetEnvVar("SM_COMMON_NAME_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := true
		if isRequired {
			errs = append(errs, "required environment variable SM_COMMON_NAME_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "string")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_COMMON_NAME").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_ORG as string
	value = GetEnvVar("SM_ORG_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_ORG_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "string")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_ORG").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_COUNTRY as string
	value = GetEnvVar("SM_COUNTRY_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_COUNTRY_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "string")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_COUNTRY").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_SAN as string
	value = GetEnvVar("SM_SAN_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_SAN_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "string")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_SAN").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_EXPIRATION_DAYS as integer
	value = GetEnvVar("SM_EXPIRATION_DAYS_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_EXPIRATION_DAYS_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "integer")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_EXPIRATION_DAYS").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_KEY_ALGO as enum[RSA|ECDSA]
	value = GetEnvVar("SM_KEY_ALGO_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_KEY_ALGO_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "enum[RSA|ECDSA]")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_KEY_ALGO").Set(reflect.ValueOf(processedValue))
		}
	}

	// Process SM_SIGN_ALGO as enum[SHA256|SHA512]
	value = GetEnvVar("SM_SIGN_ALGO_VALUE")

	// Skip if value is empty and not explicitly required
	if value == "" {
		isRequired := false
		if isRequired {
			errs = append(errs, "required environment variable SM_SIGN_ALGO_VALUE is not set")
		}
	} else {
		// Process the value based on type
		processedValue, err = processValue(value, "enum[SHA256|SHA512]")
		if err != nil {
			errs = append(errs, err.Error())
		} else {
			// Add to config
			reflect.ValueOf(&config).Elem().FieldByName("SM_SIGN_ALGO").Set(reflect.ValueOf(processedValue))
		}
	}

	if len(errs) > 0 {
		return config, fmt.Errorf("configuration errors: %s", strings.Join(errs, "; "))
	}

	return config, nil
}

// Create interfaces for secrets manager client APIs
type SecretsManagerClient interface {
	GetSecret(options *sm.GetSecretOptions) (sm.SecretIntf, *core.DetailedResponse, error)
	ReplaceSecretTask(options *sm.ReplaceSecretTaskOptions) (*sm.SecretTask, *core.DetailedResponse, error)
	NewSecretTaskError(code, description string) (*sm.SecretTaskError, error)
	NewCustomCredentialsNewCredentials(id string, credentials map[string]interface{}) (*sm.CustomCredentialsNewCredentials, error)
}

// Implement the interface with a concrete struct that wraps the actual secret manager client
type SMClient struct {
	client *sm.SecretsManagerV2
}

var validate = validator.New()

func (s *SMClient) GetSecret(options *sm.GetSecretOptions) (sm.SecretIntf, *core.DetailedResponse, error) {
	return s.client.GetSecret(options)
}

func (s *SMClient) ReplaceSecretTask(options *sm.ReplaceSecretTaskOptions) (*sm.SecretTask, *core.DetailedResponse, error) {
	return s.client.ReplaceSecretTask(options)
}

func (s *SMClient) NewSecretTaskError(code, description string) (*sm.SecretTaskError, error) {
	return s.client.NewSecretTaskError(code, description)
}

func (s *SMClient) NewCustomCredentialsNewCredentials(id string, credentials map[string]interface{}) (*sm.CustomCredentialsNewCredentials, error) {
	return s.client.NewCustomCredentialsNewCredentials(id, credentials)
}

// Function to create new client with configuration
func NewSecretsManagerClient(config Config) (SecretsManagerClient, error) {
	iamURL := getIAMURL(config.SM_INSTANCE_URL)

	service, err := sm.NewSecretsManagerV2(&sm.SecretsManagerV2Options{
		URL: config.SM_INSTANCE_URL,
		Authenticator: &core.IamAuthenticator{
			URL:    iamURL,
			ApiKey: config.SM_ACCESS_APIKEY,
		},
	})

	if err != nil {
		return nil, fmt.Errorf("failed to initialize Secrets Manager service: %w", err)
	}

	return &SMClient{client: service}, nil
}

func getIAMURL(instanceURL string) string {
	if strings.Contains(instanceURL, "secrets-manager.test.appdomain.cloud") {
		return "https://iam.test.cloud.ibm.com"
	}
	return "https://iam.cloud.ibm.com"
}

// GetSecret retrieves a secret from the IBM Cloud Secret Manager service.
func GetSecret(client SecretsManagerClient, id string) (sm.SecretIntf, error) {
	options := &sm.GetSecretOptions{ID: core.StringPtr(id)}
	res, resp, err := client.GetSecret(options)
	if err != nil {
		return nil, fmt.Errorf("cannot get secret with ID '%s': %w", id, err)
	}
	if resp == nil || resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("cannot get secret with ID '%s'. unexpected status code %d", id, resp.StatusCode)
	}
	return res, nil
}

// GetEnvVar returns the value of the environment variable for the given key
func GetEnvVar(key string) string {
	return os.Getenv(key)
}

// MustGetEnvVar returns the value of the environment variable or an error if it's not set
func MustGetEnvVar(key string) (string, error) {
	value := os.Getenv(key)
	if value == "" {
		return "", fmt.Errorf("environment variable %s is required but not set", key)
	}
	return value, nil
}

// Helper function to process values based on their type
func processValue(value string, valueType string) (interface{}, error) {
	switch valueType {
	case "string":
		return value, nil
	case "integer":
		return strconv.Atoi(value)
	case "boolean":
		return strconv.ParseBool(value)
	default:
		return value, nil // Default to string if type is unknown
	}
}

// UpdateTaskAboutCredentialsCreated updates a task status to succeeded and adds credentials to it.
func UpdateTaskAboutCredentialsCreated(client SecretsManagerClient, config *Config, credentialsPayload CredentialsPayload) (*sm.SecretTask, error) {
	credentialsPayloadMap, err := ValidatedStructToMap(credentialsPayload)
	if err != nil {
		return nil, fmt.Errorf("cannot convert credentials payload to map: %w", err)
	}

	customCredentials, err := client.NewCustomCredentialsNewCredentials(config.SM_CREDENTIALS_ID, credentialsPayloadMap)
	if err != nil {
		return nil, fmt.Errorf("cannot construct a custom credentials resource: %w", err)
	}

	secretTaskPrototype := &sm.SecretTaskPrototypeUpdateSecretTaskCredentialsCreated{
		Status:      core.StringPtr(sm.SecretTask_Status_CredentialsCreated),
		Credentials: customCredentials,
	}

	return UpdateTask(client, config, secretTaskPrototype)
}

// UpdateTaskAboutCredentialsDeleted updates a task status to succeeded when credentials are deleted.
func UpdateTaskAboutCredentialsDeleted(client SecretsManagerClient, config *Config) (result *sm.SecretTask, err error) {
	secretTaskPrototype := &sm.SecretTaskPrototypeUpdateSecretTaskCredentialsDeleted{
		Status: core.StringPtr(sm.SecretTask_Status_CredentialsDeleted),
	}
	return UpdateTask(client, config, secretTaskPrototype)
}

// UpdateTaskAboutError updates a task with the given code and description as errors.
func UpdateTaskAboutError(client SecretsManagerClient, config *Config, code, description string) (result *sm.SecretTask, err error) {

	secretTaskError, err := client.NewSecretTaskError(code, description)
	if err != nil {
		return nil, fmt.Errorf("cannot construct a new secret task error resource: %w", err)
	}

	secretTaskPrototype := &sm.SecretTaskPrototypeUpdateSecretTaskFailed{
		Status: core.StringPtr(sm.SecretTask_Status_Failed),
		Errors: []sm.SecretTaskError{*secretTaskError},
	}

	return UpdateTask(client, config, secretTaskPrototype)
}

// UpdateTask updates a secret task.
func UpdateTask(client SecretsManagerClient, config *Config, secretTaskPrototypeIntf sm.SecretTaskPrototypeIntf) (*sm.SecretTask, error) {
	options := &sm.ReplaceSecretTaskOptions{
		SecretID: &config.SM_SECRET_ID,
		ID:       &config.SM_SECRET_TASK_ID,
		TaskPut:  secretTaskPrototypeIntf,
	}

	result, response, err := client.ReplaceSecretTask(options)
	if err != nil {
		return nil, fmt.Errorf("cannot update secret with ID: '%s' task with ID: '%s'. error: %w",
			config.SM_SECRET_ID, config.SM_SECRET_TASK_ID, err)
	}

	if response == nil {
		return nil, fmt.Errorf("cannot update secret task, no response")
	}

	if response.StatusCode != 200 {
		return nil, fmt.Errorf("cannot update secret with ID: '%s' task with ID: '%s'. status code is: '%d', response is %s",
			config.SM_SECRET_ID, config.SM_SECRET_TASK_ID, response.StatusCode, response.String())
	}

	return result, nil
}

// ValidatedStructToMap converts a struct to a map[string]interface{} while performing validation
// according to the struct's validation tags
func ValidatedStructToMap(input any) (map[string]interface{}, error) {
	if input == nil {
		return nil, errors.New("input cannot be nil")
	}

	// Validate the struct based on validation tags
	if err := validate.Struct(input); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Marshal the struct to JSON
	jsonData, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal struct to JSON: %w", err)
	}

	// Unmarshal JSON back to a map
	var result map[string]interface{}
	if err := json.Unmarshal(jsonData, &result); err != nil {
		return nil, fmt.Errorf("failed to unmarshal JSON to map: %w", err)
	}

	return result, nil
}

func GetValueByPath(data map[string]interface{}, path string) (interface{}, bool) {
	segments := strings.Split(path, "/")

	var current interface{} = data // Use interface{} to allow type switching

	for _, segment := range segments {
		switch v := current.(type) {
		case map[string]interface{}:
			// Handle map keys
			val, exists := v[segment]
			if !exists {
				return nil, false
			}
			current = val
		case []interface{}:
			// Handle array indices
			index, err := strconv.Atoi(segment)
			if err != nil || index < 0 || index >= len(v) {
				return nil, false
			}
			current = v[index]
		default:
			return nil, false
		}
	}
	return current, true
}
